<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="insn.css" /><meta name="generator" content="iform.xsl" /><title>UZP1, UZP2 (vectors)</title></head><body><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h2 class="instruction-section">UZP1, UZP2 (vectors)</h2><p class="desc">Concatenate even or odd elements from two vectors.
          <p></p><p>
      <p class="aml">Concatenate adjacent even or odd-numbered elements from the first and second source vectors and place in elements of the destination vector. This instruction is unpredicated. The 128-bit element variant of this instruction requires that the current vector length is at least 256 bits, and if the current vector length is not an integer multiple of 256 bits then the trailing bits are set to zero.</p>
      <p class="aml">ID_AA64ZFR0_EL1.F64MM indicates whether the 128-bit element variant of the instruction is implemented.</p>
    </p></p>
    <p class="desc">
      It has encodings from 4 classes:
      <a href="#sve_even">Even</a>
      , 
      <a href="#sve_even_quad">Even (quadwords)</a>
      , 
      <a href="#sve_odd">Odd</a>
       and 
      <a href="#sve_odd_quad">Odd (quadwords)</a>
    </p>
    <h3 class="classheading"><a name="sve_even" id="sve_even"></a>Even</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td colspan="2" class="lr">size</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">0</td><td>1</td><td class="r">1</td><td class="l">0</td><td class="r">1</td><td class="lr">0</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zd</td></tr><tr class="secondrow"><td colspan="8"></td><td colspan="2"></td><td></td><td colspan="5"></td><td colspan="3"></td><td colspan="2"></td><td class="droppedname">H</td><td colspan="5"></td><td colspan="5"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"></h4><p class="asm-code"><a name="uzp1_z_zz_" id="uzp1_z_zz_"></a>UZP1    <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a>, <a href="#zn" title="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a>, <a href="#zm" title="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a></p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() then UNDEFINED;
integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer part = 0;</p>
    <h3 class="classheading"><a name="sve_even_quad" id="sve_even_quad"></a>Even (quadwords)</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">0</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td class="lr">0</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zd</td></tr><tr class="secondrow"><td colspan="9"></td><td></td><td></td><td colspan="5"></td><td colspan="3"></td><td colspan="2"></td><td class="droppedname">H</td><td colspan="5"></td><td colspan="5"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"></h4><p class="asm-code"><a name="uzp1_z_zz_q" id="uzp1_z_zz_q"></a>UZP1    <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd&gt;</a>.Q, <a href="#zn" title="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.Q, <a href="#zm" title="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.Q</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVEFP64MatMulExt.0" title="function: boolean HaveSVEFP64MatMulExt()">HaveSVEFP64MatMulExt</a>() then UNDEFINED;
integer esize = 128;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer part = 0;</p>
    <h3 class="classheading"><a name="sve_odd" id="sve_odd"></a>Odd</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td colspan="2" class="lr">size</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">0</td><td>1</td><td class="r">1</td><td class="l">0</td><td class="r">1</td><td class="lr">1</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zd</td></tr><tr class="secondrow"><td colspan="8"></td><td colspan="2"></td><td></td><td colspan="5"></td><td colspan="3"></td><td colspan="2"></td><td class="droppedname">H</td><td colspan="5"></td><td colspan="5"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"></h4><p class="asm-code"><a name="uzp2_z_zz_" id="uzp2_z_zz_"></a>UZP2    <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a>, <a href="#zn" title="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a>, <a href="#zm" title="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.<a href="#t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a></p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() then UNDEFINED;
integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer part = 1;</p>
    <h3 class="classheading"><a name="sve_odd_quad" id="sve_odd_quad"></a>Odd (quadwords)</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">0</td><td class="lr">1</td><td colspan="5" class="lr">Zm</td><td class="l">0</td><td>0</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td class="lr">1</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zd</td></tr><tr class="secondrow"><td colspan="9"></td><td></td><td></td><td colspan="5"></td><td colspan="3"></td><td colspan="2"></td><td class="droppedname">H</td><td colspan="5"></td><td colspan="5"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"></h4><p class="asm-code"><a name="uzp2_z_zz_q" id="uzp2_z_zz_q"></a>UZP2    <a href="#zd" title="Destination scalable vector register (field &quot;Zd&quot;)">&lt;Zd&gt;</a>.Q, <a href="#zn" title="First source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.Q, <a href="#zm" title="Second source scalable vector register (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.Q</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVEFP64MatMulExt.0" title="function: boolean HaveSVEFP64MatMulExt()">HaveSVEFP64MatMulExt</a>() then UNDEFINED;
integer esize = 128;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zm);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zd);
integer part = 1;</p>
  <p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zd&gt;</td><td><a name="zd" id="zd"></a>
        
          <p class="aml">Is the name of the destination scalable vector register, encoded in the "Zd" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;T&gt;</td><td><a name="t" id="t"></a>
        Is the size specifier, 
    encoded in 
    <q>size</q>:
      
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;T&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">B</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">H</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">S</td>
              </tr>
              <tr>
                <td class="bitfield">11</td>
                <td class="symbol">D</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zn&gt;</td><td><a name="zn" id="zn"></a>
        
          <p class="aml">Is the name of the first source scalable vector register, encoded in the "Zn" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zm&gt;</td><td><a name="zm" id="zm"></a>
        
          <p class="aml">Is the name of the second source scalable vector register, encoded in the "Zm" field.</p>
        
      </td></tr></table></div><p class="syntax-notes"></p>
    <div class="ps" psname="execute"><a name="execute" id="execute"></a><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()">CheckSVEEnabled</a>();
if <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> &lt; esize * 2 then UNDEFINED;
integer elements = <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> DIV esize;
bits(<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>) operand1 = <a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]">Z</a>[n];
bits(<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>) operand2 = <a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]">Z</a>[m];
bits(<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>) result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

bits(<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>*2) zipped = operand2:operand1;
for e = 0 to elements-1
    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[zipped, 2*e+part, esize];

<a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value">Z</a>[d] = result;</p>
    </div>
  <hr /><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v32.13, AdvSIMD v29.05, pseudocode v2020-12, sve v2020-12
      ; Build timestamp: 2020-12-16T16:19
    </p><p class="copyconf">
      Copyright © 2010-2020 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
